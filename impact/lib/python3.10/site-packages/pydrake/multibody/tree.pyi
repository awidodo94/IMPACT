from typing import Any, ClassVar, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common.cpp_template
import pydrake.common.eigen_geometry
import pydrake.common.value
import pydrake.math
import pydrake.multibody.math
import pydrake.symbolic
import pydrake.systems.framework
BallRpyJoint_: pydrake.common.cpp_template.TemplateClass
BodyFrame_: pydrake.common.cpp_template.TemplateClass
Body_: pydrake.common.cpp_template.TemplateClass
DoorHinge_: pydrake.common.cpp_template.TemplateClass
FixedOffsetFrame_: pydrake.common.cpp_template.TemplateClass
ForceElement_: pydrake.common.cpp_template.TemplateClass
Frame_: pydrake.common.cpp_template.TemplateClass
JointActuator_: pydrake.common.cpp_template.TemplateClass
Joint_: pydrake.common.cpp_template.TemplateClass
LinearBushingRollPitchYaw_: pydrake.common.cpp_template.TemplateClass
LinearSpringDamper_: pydrake.common.cpp_template.TemplateClass
MultibodyForces_: pydrake.common.cpp_template.TemplateClass
PlanarJoint_: pydrake.common.cpp_template.TemplateClass
PrismaticJoint_: pydrake.common.cpp_template.TemplateClass
PrismaticSpring_: pydrake.common.cpp_template.TemplateClass
QuaternionFloatingJoint_: pydrake.common.cpp_template.TemplateClass
RevoluteJoint_: pydrake.common.cpp_template.TemplateClass
RevoluteSpring_: pydrake.common.cpp_template.TemplateClass
RigidBody_: pydrake.common.cpp_template.TemplateClass
RotationalInertia_: pydrake.common.cpp_template.TemplateClass
ScrewJoint_: pydrake.common.cpp_template.TemplateClass
SpatialInertia_: pydrake.common.cpp_template.TemplateClass
UniformGravityFieldElement_: pydrake.common.cpp_template.TemplateClass
UnitInertia_: pydrake.common.cpp_template.TemplateClass
UniversalJoint_: pydrake.common.cpp_template.TemplateClass
WeldJoint_: pydrake.common.cpp_template.TemplateClass

class BallRpyJoint(Joint):
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context, angles: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context, w_FM: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class BallRpyJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class BallRpyJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣Expression𝓤: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣Expression𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class Body:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialAcceleration: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialVelocity: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context) -> None: ...
    def body_frame(self) -> BodyFrame: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    @overload
    def is_locked(self, context: pydrake.systems.framework.Context) -> bool: ...
    @overload
    def is_locked(self) -> Any: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class BodyFrame(Frame):
    def __init__(self, *args, **kwargs) -> None: ...

class BodyFrame_𝓣AutoDiffXd𝓤(Frame_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyFrame_𝓣Expression𝓤(Frame_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: BodyIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: BodyIndex) -> bool: ...

class Body_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def body_frame(self) -> BodyFrame_𝓣AutoDiffXd𝓤: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    @overload
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> bool: ...
    @overload
    def is_locked(self) -> Any: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class Body_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def body_frame(self) -> BodyFrame_𝓣Expression𝓤: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    @overload
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> bool: ...
    @overload
    def is_locked(self) -> Any: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class DoorHinge(ForceElement):
    def __init__(self, joint: RevoluteJoint, config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: float) -> float: ...
    def CalcHingeSpringTorque(self, angle: float) -> float: ...
    def CalcHingeTorque(self, angle: float, angular_rate: float) -> float: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint: ...

class DoorHingeConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    catch_torque: float
    catch_width: float
    dynamic_friction_torque: float
    motion_threshold: float
    spring_constant: float
    spring_zero_angle_rad: float
    static_friction_torque: float
    viscous_friction: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> DoorHingeConfig: ...
    def __deepcopy__(self, arg0: dict) -> DoorHingeConfig: ...

class DoorHinge_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣AutoDiffXd𝓤, config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeSpringTorque(self, angle: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeTorque(self, angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...

class DoorHinge_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣Expression𝓤, config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeSpringTorque(self, angle: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeTorque(self, angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_𝓣Expression𝓤: ...

class FixedOffsetFrame(Frame):
    def __init__(self, name: str, P: Frame, X_PF: pydrake.math.RigidTransform, model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context, X_PF: pydrake.math.RigidTransform) -> None: ...

class FixedOffsetFrame_𝓣AutoDiffXd𝓤(Frame_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_𝓣AutoDiffXd𝓤, X_PF: pydrake.math.RigidTransform, model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_PF: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> None: ...

class FixedOffsetFrame_𝓣Expression𝓤(Frame_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_𝓣Expression𝓤, X_PF: pydrake.math.RigidTransform, model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_PF: pydrake.math.RigidTransform_𝓣Expression𝓤) -> None: ...

class ForceElement:
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class ForceElementIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: ForceElementIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: ForceElementIndex) -> bool: ...

class ForceElement_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class ForceElement_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class Frame:
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context, measured_in_frame: Frame, expressed_in_frame: Frame) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context, X_FQ: pydrake.math.RigidTransform) -> pydrake.math.RigidTransform: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context, R_FQ: pydrake.math.RotationMatrix) -> pydrake.math.RotationMatrix: ...
    def CalcPose(self, context: pydrake.systems.framework.Context, frame_M: Frame) -> pydrake.math.RigidTransform: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context, other_frame: Frame, measured_in_frame: Frame, expressed_in_frame: Frame) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context, other_frame: Frame) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context, other_frame: Frame, measured_in_frame: Frame, expressed_in_frame: Frame) -> pydrake.multibody.math.SpatialVelocity: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context, other_frame: Frame) -> pydrake.multibody.math.SpatialVelocity: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context, frame_M: Frame) -> pydrake.math.RotationMatrix: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context) -> pydrake.math.RotationMatrix: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.math.RotationMatrix: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context, measured_in_frame: Frame, expressed_in_frame: Frame) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context, frame_M: Frame, frame_E: Frame) -> pydrake.multibody.math.SpatialVelocity: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialVelocity: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform) -> pydrake.math.RigidTransform: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix) -> pydrake.math.RotationMatrix: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class FrameIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: FrameIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: FrameIndex) -> bool: ...

class Frame_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_FQ: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, R_FQ: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤, frame_E: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class Frame_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_FQ: pydrake.math.RigidTransform_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, R_FQ: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤, frame_E: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class JacobianWrtVariable:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kQDot: ClassVar[JacobianWrtVariable] = ...
    kV: ClassVar[JacobianWrtVariable] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Joint:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context) -> float: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context) -> float: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame: ...
    def frame_on_parent(self) -> Frame: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class JointActuator:
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def SetGearRatio(self, context: pydrake.systems.framework.Context, gear_ratio: float) -> None: ...
    def SetRotorInertia(self, context: pydrake.systems.framework.Context, rotor_inertia: float) -> None: ...
    def calc_reflected_inertia(self, context: pydrake.systems.framework.Context) -> float: ...
    def default_gear_ratio(self) -> float: ...
    def default_reflected_inertia(self) -> float: ...
    def default_rotor_inertia(self) -> float: ...
    def effort_limit(self) -> float: ...
    def gear_ratio(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_controller_gains(self) -> PdControllerGains: ...
    def has_controller(self) -> bool: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def rotor_inertia(self, context: pydrake.systems.framework.Context) -> float: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def set_controller_gains(self, gains: PdControllerGains) -> None: ...
    def set_default_gear_ratio(self, gear_ratio: float) -> None: ...
    def set_default_rotor_inertia(self, rotor_inertia: float) -> None: ...

class JointActuatorIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: JointActuatorIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: JointActuatorIndex) -> bool: ...

class JointActuator_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def SetGearRatio(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, gear_ratio: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetRotorInertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, rotor_inertia: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def calc_reflected_inertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def default_gear_ratio(self) -> float: ...
    def default_reflected_inertia(self) -> float: ...
    def default_rotor_inertia(self) -> float: ...
    def effort_limit(self) -> float: ...
    def gear_ratio(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def get_controller_gains(self) -> PdControllerGains: ...
    def has_controller(self) -> bool: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_𝓣AutoDiffXd𝓤: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def rotor_inertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def set_controller_gains(self, gains: PdControllerGains) -> None: ...
    def set_default_gear_ratio(self, gear_ratio: float) -> None: ...
    def set_default_rotor_inertia(self, rotor_inertia: float) -> None: ...

class JointActuator_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def SetGearRatio(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, gear_ratio: pydrake.symbolic.Expression) -> None: ...
    def SetRotorInertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, rotor_inertia: pydrake.symbolic.Expression) -> None: ...
    def calc_reflected_inertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def default_gear_ratio(self) -> float: ...
    def default_reflected_inertia(self) -> float: ...
    def default_rotor_inertia(self) -> float: ...
    def effort_limit(self) -> float: ...
    def gear_ratio(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def get_controller_gains(self) -> PdControllerGains: ...
    def has_controller(self) -> bool: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_𝓣Expression𝓤: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def rotor_inertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def set_controller_gains(self, gains: PdControllerGains) -> None: ...
    def set_default_gear_ratio(self, gear_ratio: float) -> None: ...
    def set_default_rotor_inertia(self, rotor_inertia: float) -> None: ...

class JointIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: JointIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: JointIndex) -> bool: ...

class Joint_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def frame_on_parent(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class Joint_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_𝓣Expression𝓤: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_𝓣Expression𝓤: ...
    def frame_on_parent(self) -> Frame_𝓣Expression𝓤: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_𝓣Expression𝓤: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class LinearBushingRollPitchYaw(ForceElement):
    def __init__(self, frameA: Frame, frameC: Frame, torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialForce: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context) -> pydrake.multibody.math.SpatialForce: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context, force_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context, force_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context, torque_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context, torque_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame: ...
    def frameC(self) -> Frame: ...
    def link0(self) -> Body: ...
    def link1(self) -> Body: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearBushingRollPitchYaw_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_𝓣AutoDiffXd𝓤, frameC: Frame_𝓣AutoDiffXd𝓤, torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def frameC(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def link0(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def link1(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearBushingRollPitchYaw_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_𝓣Expression𝓤, frameC: Frame_𝓣Expression𝓤, torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_𝓣Expression𝓤: ...
    def frameC(self) -> Frame_𝓣Expression𝓤: ...
    def link0(self) -> Body_𝓣Expression𝓤: ...
    def link1(self) -> Body_𝓣Expression𝓤: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearSpringDamper(ForceElement):
    def __init__(self, bodyA: Body, p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body, p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body: ...
    def bodyB(self) -> Body: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class LinearSpringDamper_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def bodyB(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class LinearSpringDamper_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_𝓣Expression𝓤: ...
    def bodyB(self) -> Body_𝓣Expression𝓤: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class ModelInstanceIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: ModelInstanceIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: ModelInstanceIndex) -> bool: ...

class MultibodyConstraintId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> MultibodyConstraintId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: MultibodyConstraintId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: MultibodyConstraintId) -> bool: ...
    def __ne__(self, arg0: MultibodyConstraintId) -> bool: ...

class MultibodyForces:
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces) -> None: ...
    def SetZero(self) -> MultibodyForces: ...
    def generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces: ...

class MultibodyForces_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_𝓣AutoDiffXd𝓤) -> None: ...
    def SetZero(self) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...

class MultibodyForces_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_𝓣Expression𝓤) -> None: ...
    def SetZero(self) -> MultibodyForces_𝓣Expression𝓤: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_𝓣Expression𝓤: ...

class PdControllerGains:
    d: float
    p: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> PdControllerGains: ...
    def __deepcopy__(self, arg0: dict) -> PdControllerGains: ...

class PlanarJoint(Joint):
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context, theta_dot: float) -> PlanarJoint: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> PlanarJoint: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context, theta: float) -> PlanarJoint: ...
    def set_translation(self, context: pydrake.systems.framework.Context, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context, v_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint: ...

class PlanarJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...

class PlanarJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣Expression𝓤: ...

class PrismaticJoint(Joint):
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context, translation: float) -> PrismaticJoint: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context, translation_dot: float) -> PrismaticJoint: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation_dot: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation: pydrake.symbolic.Expression) -> PrismaticJoint_𝓣Expression𝓤: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation_dot: pydrake.symbolic.Expression) -> PrismaticJoint_𝓣Expression𝓤: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticSpring(ForceElement):
    def __init__(self, joint: PrismaticJoint, nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class PrismaticSpring_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_𝓣AutoDiffXd𝓤, nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class PrismaticSpring_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_𝓣Expression𝓤, nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_𝓣Expression𝓤: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class QuaternionFloatingJoint(Joint):
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context, R_FM: pydrake.math.RotationMatrix) -> QuaternionFloatingJoint: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_pose(self, context: pydrake.systems.framework.Context) -> pydrake.math.RigidTransform: ...
    def get_position(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context, w_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context, X_FM: pydrake.math.RigidTransform) -> QuaternionFloatingJoint: ...
    def set_position(self, context: pydrake.systems.framework.Context, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context, q_FM: pydrake.common.eigen_geometry.Quaternion) -> QuaternionFloatingJoint: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context, v_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint: ...
    def translational_damping(self) -> float: ...

class QuaternionFloatingJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, R_FM: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def get_position(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_position(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def translational_damping(self) -> float: ...

class QuaternionFloatingJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, R_FM: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def get_position(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_position(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def translational_damping(self) -> float: ...

class RevoluteJoint(Joint):
    @overload
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context, angle: float) -> RevoluteJoint: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context, angle: float) -> RevoluteJoint: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angle: pydrake.symbolic.Expression) -> RevoluteJoint_𝓣Expression𝓤: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angle: pydrake.symbolic.Expression) -> RevoluteJoint_𝓣Expression𝓤: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteSpring(ForceElement):
    def __init__(self, joint: RevoluteJoint, nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RevoluteSpring_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣AutoDiffXd𝓤, nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RevoluteSpring_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣Expression𝓤, nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_𝓣Expression𝓤: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RigidBody(Body):
    def __init__(self, *args, **kwargs) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context, com: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context, mass: float) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self, *args, **kwargs) -> Any: ...
    def default_spatial_inertia(self, *args, **kwargs) -> Any: ...
    def default_unit_inertia(self, *args, **kwargs) -> Any: ...

class RigidBody_𝓣AutoDiffXd𝓤(Body_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, mass: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia: ...
    def default_spatial_inertia(self) -> SpatialInertia: ...
    def default_unit_inertia(self) -> UnitInertia: ...

class RigidBody_𝓣Expression𝓤(Body_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, mass: pydrake.symbolic.Expression) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia: ...
    def default_spatial_inertia(self) -> SpatialInertia: ...
    def default_unit_inertia(self) -> UnitInertia: ...

class RotationalInertia:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> float: ...
    def CalcPrincipalMomentsAndAxesOfInertia(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],pydrake.math.RotationMatrix]: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia, precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix) -> RotationalInertia: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia: ...
    def ShiftToCenterOfMass(self, mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3,1]], p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia: ...
    def Trace(self) -> float: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: float) -> RotationalInertia: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_products(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia) -> RotationalInertia: ...
    def __copy__(self) -> RotationalInertia: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia: ...
    def __getitem__(self, arg0: tuple) -> float: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia) -> RotationalInertia: ...
    def __imul__(self, arg0: float) -> RotationalInertia: ...
    def __isub__(self, arg0: RotationalInertia) -> RotationalInertia: ...
    def __itruediv__(self, arg0: float) -> RotationalInertia: ...
    @overload
    def __mul__(self, arg0: float) -> RotationalInertia: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __rmul__(self, arg0: float) -> RotationalInertia: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia) -> RotationalInertia: ...
    def __truediv__(self, arg0: float) -> RotationalInertia: ...

class RotationalInertia_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcPrincipalMomentsAndAxesOfInertia(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],pydrake.math.RotationMatrix]: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_𝓣AutoDiffXd𝓤, precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def Trace(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __getitem__(self, arg0: tuple) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __imul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __isub__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __itruediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __truediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...

class RotationalInertia_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.symbolic.Expression: ...
    def CalcPrincipalMomentsAndAxesOfInertia(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],pydrake.math.RotationMatrix]: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_𝓣Expression𝓤, precision: float) -> pydrake.symbolic.Formula: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def ShiftToCenterOfMass(self, mass: pydrake.symbolic.Expression, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def Trace(self) -> pydrake.symbolic.Expression: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> RotationalInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_𝓣Expression𝓤: ...
    def __getitem__(self, arg0: tuple) -> pydrake.symbolic.Expression: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __imul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    def __isub__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __itruediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __truediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...

class ScopedName:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, namespace_name: str, element_name: str) -> None: ...
    @classmethod
    def Join(cls, name1: str, name2: str) -> ScopedName: ...
    @classmethod
    def Make(cls, namespace_name: str, element_name: str) -> Optional[ScopedName]: ...
    @classmethod
    def Parse(cls, scoped_name: str) -> ScopedName: ...
    def get_element(self) -> str: ...
    def get_full(self) -> str: ...
    def get_namespace(self) -> str: ...
    def set_element(self, element_name: str) -> None: ...
    def set_namespace(self, namespace_name: str) -> None: ...
    def to_string(self) -> str: ...
    def __copy__(self) -> ScopedName: ...
    def __deepcopy__(self, arg0: dict) -> ScopedName: ...

class ScrewJoint(Joint):
    @overload
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, screw_pitch: float, damping: float) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context) -> float: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context) -> float: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context, theta_dot: float) -> ScrewJoint: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context, translation: float) -> ScrewJoint: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context, translation_dot: float) -> ScrewJoint: ...

class ScrewJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, screw_pitch: float, damping: float) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...

class ScrewJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, screw_pitch: float, damping: float) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation_dot: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...

class SpatialInertia:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3,1]], G_SP_E: UnitInertia, skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[numpy.float64[6,6]]: ...
    @classmethod
    def HollowSphereWithDensity(cls, area_density: float, radius: float) -> SpatialInertia: ...
    @classmethod
    def HollowSphereWithMass(cls, mass: float, radius: float) -> SpatialInertia: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    @classmethod
    def MakeFromCentralInertia(cls, mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3,1]], I_SScm_E: RotationalInertia) -> SpatialInertia: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix) -> SpatialInertia: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidBoxWithDensity(cls, density: float, lx: float, ly: float, lz: float) -> SpatialInertia: ...
    @classmethod
    def SolidBoxWithMass(cls, mass: float, lx: float, ly: float, lz: float) -> SpatialInertia: ...
    @classmethod
    def SolidCapsuleWithDensity(cls, density: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidCapsuleWithMass(cls, mass: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidCubeWithDensity(cls, density: float, length: float) -> SpatialInertia: ...
    @classmethod
    def SolidCylinderWithDensity(cls, density: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidCylinderWithDensityAboutEnd(cls, density: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidCylinderWithMass(cls, mass: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidCylinderWithMassAboutEnd(cls, mass: float, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def SolidEllipsoidWithDensity(cls, density: float, a: float, b: float, c: float) -> SpatialInertia: ...
    @classmethod
    def SolidEllipsoidWithMass(cls, mass: float, a: float, b: float, c: float) -> SpatialInertia: ...
    @classmethod
    def SolidSphereWithDensity(cls, density: float, radius: float) -> SpatialInertia: ...
    @classmethod
    def SolidSphereWithMass(cls, mass: float, radius: float) -> SpatialInertia: ...
    @classmethod
    def ThinRodWithMass(cls, mass: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    @classmethod
    def ThinRodWithMassAboutEnd(cls, mass: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia: ...
    def get_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_mass(self) -> float: ...
    def get_unit_inertia(self) -> UnitInertia: ...
    def __copy__(self) -> SpatialInertia: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia) -> SpatialInertia: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration) -> pydrake.multibody.math.SpatialForce: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity) -> pydrake.multibody.math.SpatialMomentum: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SpatialInertia_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_𝓣AutoDiffXd𝓤, skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    @classmethod
    def HollowSphereWithDensity(cls, area_density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def HollowSphereWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    @classmethod
    def MakeFromCentralInertia(cls, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], I_SScm_E: RotationalInertia_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBoxWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, lx: pydrake.autodiffutils.AutoDiffXd, ly: pydrake.autodiffutils.AutoDiffXd, lz: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBoxWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, lx: pydrake.autodiffutils.AutoDiffXd, ly: pydrake.autodiffutils.AutoDiffXd, lz: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCapsuleWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCapsuleWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCubeWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithDensityAboutEnd(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithMassAboutEnd(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoidWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoidWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphereWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphereWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def ThinRodWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def ThinRodWithMassAboutEnd(cls, mass: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_unit_inertia(self) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SpatialInertia_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_𝓣Expression𝓤, skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_𝓣Expression𝓤: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    @classmethod
    def HollowSphereWithDensity(cls, area_density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def HollowSphereWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsPhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @classmethod
    def MakeFromCentralInertia(cls, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], I_SScm_E: RotationalInertia_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBoxWithDensity(cls, density: pydrake.symbolic.Expression, lx: pydrake.symbolic.Expression, ly: pydrake.symbolic.Expression, lz: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBoxWithMass(cls, mass: pydrake.symbolic.Expression, lx: pydrake.symbolic.Expression, ly: pydrake.symbolic.Expression, lz: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCapsuleWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCapsuleWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCubeWithDensity(cls, density: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithDensityAboutEnd(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithMassAboutEnd(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoidWithDensity(cls, density: pydrake.symbolic.Expression, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoidWithMass(cls, mass: pydrake.symbolic.Expression, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphereWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphereWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def ThinRodWithMass(cls, mass: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def ThinRodWithMassAboutEnd(cls, mass: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.symbolic.Expression: ...
    def get_unit_inertia(self) -> UnitInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> SpatialInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_𝓣Expression𝓤: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class UniformGravityFieldElement(ForceElement):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def is_enabled(self, model_instance: ModelInstanceIndex) -> bool: ...
    def set_enabled(self, model_instance: ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UniformGravityFieldElement_𝓣AutoDiffXd𝓤(ForceElement_𝓣AutoDiffXd𝓤):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def is_enabled(self, model_instance: ModelInstanceIndex) -> bool: ...
    def set_enabled(self, model_instance: ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UniformGravityFieldElement_𝓣Expression𝓤(ForceElement_𝓣Expression𝓤):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def is_enabled(self, model_instance: ModelInstanceIndex) -> bool: ...
    def set_enabled(self, model_instance: ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UnitInertia(RotationalInertia):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia) -> None: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, moment_parallel: float, moment_perpendicular: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, J: float, K: float, b_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @classmethod
    def HollowSphere(cls, r: float) -> UnitInertia: ...
    @classmethod
    def PointMass(cls, p_FQ: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix) -> UnitInertia: ...
    def SetFromRotationalInertia(self, I: RotationalInertia, mass: float) -> UnitInertia: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @classmethod
    def SolidBox(cls, Lx: float, Ly: float, Lz: float) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCapsule(cls, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCapsule(cls, r: float, L: float, unit_vector: numpy.ndarray[numpy.float64[3,1]] = ...) -> UnitInertia: ...
    @classmethod
    def SolidCube(cls, L: float) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCylinder(cls, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCylinder(cls, r: float, L: float, b_E: numpy.ndarray[numpy.float64[3,1]] = ...) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, radius: float, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, r: float, L: float) -> UnitInertia: ...
    @classmethod
    def SolidEllipsoid(cls, a: float, b: float, c: float) -> UnitInertia: ...
    @classmethod
    def SolidSphere(cls, r: float) -> UnitInertia: ...
    @overload
    @classmethod
    def StraightLine(cls, moment_perpendicular: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def StraightLine(cls, K: float, b_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def ThinRod(cls, length: float, unit_vector: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @overload
    @classmethod
    def ThinRod(cls, L: float, b_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: float) -> UnitInertia: ...
    def __copy__(self) -> UnitInertia: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...

class UnitInertia_𝓣AutoDiffXd𝓤(RotationalInertia_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, moment_parallel: pydrake.autodiffutils.AutoDiffXd, moment_perpendicular: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, J: pydrake.autodiffutils.AutoDiffXd, K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def HollowSphere(cls, r: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def PointMass(cls, p_FQ: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_𝓣AutoDiffXd𝓤, mass: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBox(cls, Lx: pydrake.autodiffutils.AutoDiffXd, Ly: pydrake.autodiffutils.AutoDiffXd, Lz: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCube(cls, L: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoid(cls, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphere(cls, r: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, moment_perpendicular: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class UnitInertia_𝓣Expression𝓤(RotationalInertia_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_𝓣Expression𝓤) -> None: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, moment_parallel: pydrake.symbolic.Expression, moment_perpendicular: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, J: pydrake.symbolic.Expression, K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def HollowSphere(cls, r: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def PointMass(cls, p_FQ: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> UnitInertia_𝓣Expression𝓤: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_𝓣Expression𝓤, mass: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBox(cls, Lx: pydrake.symbolic.Expression, Ly: pydrake.symbolic.Expression, Lz: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCube(cls, L: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoid(cls, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphere(cls, r: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, moment_perpendicular: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> UnitInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_𝓣Expression𝓤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class UniversalJoint(Joint):
    def __init__(self, name: str, frame_on_parent: Frame, frame_on_child: Frame, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context, angles: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context, theta_dot: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class UniversalJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class UniversalJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣Expression𝓤: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣Expression𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class WeldJoint(Joint):
    def __init__(self, name: str, frame_on_parent_F: Frame, frame_on_child_M: Frame, X_FM: pydrake.math.RigidTransform) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform: ...

class WeldJoint_𝓣AutoDiffXd𝓤(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_𝓣AutoDiffXd𝓤, frame_on_child_M: Frame_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform: ...

class WeldJoint_𝓣Expression𝓤(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_𝓣Expression𝓤, frame_on_child_M: Frame_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    demangle: ClassVar[function] = ...
    mangle: ClassVar[function] = ...
    module_getattr: ClassVar[function] = ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody15ForceElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ForceElementIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ForceElementIndex: ...
    def get_value(self) -> ForceElementIndex: ...
    def set_value(self, arg0: ForceElementIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody15JointElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: JointIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> JointIndex: ...
    def get_value(self) -> JointIndex: ...
    def set_value(self, arg0: JointIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody16ModelInstanceTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ModelInstanceIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ModelInstanceIndex: ...
    def get_value(self) -> ModelInstanceIndex: ...
    def set_value(self, arg0: ModelInstanceIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody23JointActuatorElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: JointActuatorIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> JointActuatorIndex: ...
    def get_value(self) -> JointActuatorIndex: ...
    def set_value(self, arg0: JointActuatorIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody7BodyTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: BodyIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> BodyIndex: ...
    def get_value(self) -> BodyIndex: ...
    def set_value(self, arg0: BodyIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody8FrameTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FrameIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FrameIndex: ...
    def get_value(self) -> FrameIndex: ...
    def set_value(self, arg0: FrameIndex) -> None: ...

class _TemporaryName_N5drake9multibody10ScrewJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, screw_pitch: float, damping: float) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody10ScrewJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, screw_pitch: float, damping: float) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation_dot: pydrake.symbolic.Expression) -> ScrewJoint_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody11PlanarJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody11PlanarJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta: pydrake.symbolic.Expression) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣Expression𝓤: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody11UnitInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(RotationalInertia_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, moment_parallel: pydrake.autodiffutils.AutoDiffXd, moment_perpendicular: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, J: pydrake.autodiffutils.AutoDiffXd, K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def HollowSphere(cls, r: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def PointMass(cls, p_FQ: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_𝓣AutoDiffXd𝓤, mass: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBox(cls, Lx: pydrake.autodiffutils.AutoDiffXd, Ly: pydrake.autodiffutils.AutoDiffXd, Lz: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCube(cls, L: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoid(cls, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphere(cls, r: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, moment_perpendicular: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake9multibody11UnitInertiaINS_8symbolic10ExpressionEEE(RotationalInertia_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_𝓣Expression𝓤) -> None: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, moment_parallel: pydrake.symbolic.Expression, moment_perpendicular: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def AxiallySymmetric(cls, J: pydrake.symbolic.Expression, K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def HollowSphere(cls, r: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def PointMass(cls, p_FQ: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> UnitInertia_𝓣Expression𝓤: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_𝓣Expression𝓤, mass: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBox(cls, Lx: pydrake.symbolic.Expression, Ly: pydrake.symbolic.Expression, Lz: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCapsule(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCube(cls, L: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinder(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]] = ...) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def SolidCylinderAboutEnd(cls, r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoid(cls, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphere(cls, r: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, moment_perpendicular: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def StraightLine(cls, K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ThinRod(cls, L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3,1]]) -> UnitInertia_𝓣Expression𝓤: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.symbolic.Expression) -> UnitInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> UnitInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_𝓣Expression𝓤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake9multibody12BallRpyJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody12BallRpyJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣Expression𝓤: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_𝓣Expression𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody12ForceElementIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class _TemporaryName_N5drake9multibody12ForceElementINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class _TemporaryName_N5drake9multibody13JointActuatorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def SetGearRatio(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, gear_ratio: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetRotorInertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, rotor_inertia: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def calc_reflected_inertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def default_gear_ratio(self) -> float: ...
    def default_reflected_inertia(self) -> float: ...
    def default_rotor_inertia(self) -> float: ...
    def effort_limit(self) -> float: ...
    def gear_ratio(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def get_controller_gains(self) -> PdControllerGains: ...
    def has_controller(self) -> bool: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_𝓣AutoDiffXd𝓤: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def rotor_inertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def set_controller_gains(self, gains: PdControllerGains) -> None: ...
    def set_default_gear_ratio(self, gear_ratio: float) -> None: ...
    def set_default_rotor_inertia(self, rotor_inertia: float) -> None: ...

class _TemporaryName_N5drake9multibody13JointActuatorINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def SetGearRatio(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, gear_ratio: pydrake.symbolic.Expression) -> None: ...
    def SetRotorInertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, rotor_inertia: pydrake.symbolic.Expression) -> None: ...
    def calc_reflected_inertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def default_gear_ratio(self) -> float: ...
    def default_reflected_inertia(self) -> float: ...
    def default_rotor_inertia(self) -> float: ...
    def effort_limit(self) -> float: ...
    def gear_ratio(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def get_controller_gains(self) -> PdControllerGains: ...
    def has_controller(self) -> bool: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_𝓣Expression𝓤: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def rotor_inertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def set_controller_gains(self, gains: PdControllerGains) -> None: ...
    def set_default_gear_ratio(self, gear_ratio: float) -> None: ...
    def set_default_rotor_inertia(self, rotor_inertia: float) -> None: ...

class _TemporaryName_N5drake9multibody13RevoluteJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody13RevoluteJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angle: pydrake.symbolic.Expression) -> RevoluteJoint_𝓣Expression𝓤: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angle: pydrake.symbolic.Expression) -> RevoluteJoint_𝓣Expression𝓤: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14PrismaticJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, translation_dot: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14PrismaticJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_damping(self, damping: float) -> None: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation: pydrake.symbolic.Expression) -> PrismaticJoint_𝓣Expression𝓤: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, translation_dot: pydrake.symbolic.Expression) -> PrismaticJoint_𝓣Expression𝓤: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14RevoluteSpringIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣AutoDiffXd𝓤, nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody14RevoluteSpringINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣Expression𝓤, nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_𝓣Expression𝓤: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody14SpatialInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_𝓣AutoDiffXd𝓤, skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    @classmethod
    def HollowSphereWithDensity(cls, area_density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def HollowSphereWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    @classmethod
    def MakeFromCentralInertia(cls, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], I_SScm_E: RotationalInertia_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBoxWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, lx: pydrake.autodiffutils.AutoDiffXd, ly: pydrake.autodiffutils.AutoDiffXd, lz: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidBoxWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, lx: pydrake.autodiffutils.AutoDiffXd, ly: pydrake.autodiffutils.AutoDiffXd, lz: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCapsuleWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCapsuleWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCubeWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithDensityAboutEnd(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidCylinderWithMassAboutEnd(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoidWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidEllipsoidWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, a: pydrake.autodiffutils.AutoDiffXd, b: pydrake.autodiffutils.AutoDiffXd, c: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphereWithDensity(cls, density: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def SolidSphereWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, radius: pydrake.autodiffutils.AutoDiffXd) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def ThinRodWithMass(cls, mass: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def ThinRodWithMassAboutEnd(cls, mass: pydrake.autodiffutils.AutoDiffXd, length: pydrake.autodiffutils.AutoDiffXd, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_unit_inertia(self) -> UnitInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_𝓣AutoDiffXd𝓤) -> SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5drake9multibody14SpatialInertiaINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_𝓣Expression𝓤, skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_𝓣Expression𝓤: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    @classmethod
    def HollowSphereWithDensity(cls, area_density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def HollowSphereWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsPhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @classmethod
    def MakeFromCentralInertia(cls, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], I_SScm_E: RotationalInertia_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBoxWithDensity(cls, density: pydrake.symbolic.Expression, lx: pydrake.symbolic.Expression, ly: pydrake.symbolic.Expression, lz: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidBoxWithMass(cls, mass: pydrake.symbolic.Expression, lx: pydrake.symbolic.Expression, ly: pydrake.symbolic.Expression, lz: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCapsuleWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCapsuleWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCubeWithDensity(cls, density: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithDensityAboutEnd(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidCylinderWithMassAboutEnd(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoidWithDensity(cls, density: pydrake.symbolic.Expression, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidEllipsoidWithMass(cls, mass: pydrake.symbolic.Expression, a: pydrake.symbolic.Expression, b: pydrake.symbolic.Expression, c: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphereWithDensity(cls, density: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def SolidSphereWithMass(cls, mass: pydrake.symbolic.Expression, radius: pydrake.symbolic.Expression) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def ThinRodWithMass(cls, mass: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    @classmethod
    def ThinRodWithMassAboutEnd(cls, mass: pydrake.symbolic.Expression, length: pydrake.symbolic.Expression, unit_vector: numpy.ndarray[object[3,1]]) -> SpatialInertia_𝓣Expression𝓤: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.symbolic.Expression: ...
    def get_unit_inertia(self) -> UnitInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> SpatialInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_𝓣Expression𝓤: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_𝓣Expression𝓤) -> SpatialInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5drake9multibody14UniversalJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣AutoDiffXd𝓤: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class _TemporaryName_N5drake9multibody14UniversalJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣Expression𝓤: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_𝓣Expression𝓤: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class _TemporaryName_N5drake9multibody15MultibodyForcesIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_𝓣AutoDiffXd𝓤) -> None: ...
    def SetZero(self) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody15MultibodyForcesINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_𝓣Expression𝓤) -> None: ...
    def SetZero(self) -> MultibodyForces_𝓣Expression𝓤: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody15PrismaticSpringIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_𝓣AutoDiffXd𝓤, nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_𝓣AutoDiffXd𝓤: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody15PrismaticSpringINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_𝓣Expression𝓤, nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_𝓣Expression𝓤: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody16FixedOffsetFrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Frame_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_𝓣AutoDiffXd𝓤, X_PF: pydrake.math.RigidTransform, model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_PF: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> None: ...

class _TemporaryName_N5drake9multibody16FixedOffsetFrameINS_8symbolic10ExpressionEEE(Frame_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_𝓣Expression𝓤, X_PF: pydrake.math.RigidTransform, model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_PF: pydrake.math.RigidTransform_𝓣Expression𝓤) -> None: ...

class _TemporaryName_N5drake9multibody17RotationalInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcPrincipalMomentsAndAxesOfInertia(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],pydrake.math.RotationMatrix]: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_𝓣AutoDiffXd𝓤, precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def Trace(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __getitem__(self, arg0: tuple) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __imul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __isub__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __itruediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_𝓣AutoDiffXd𝓤) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...
    def __truediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody17RotationalInertiaINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.symbolic.Expression: ...
    def CalcPrincipalMomentsAndAxesOfInertia(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],pydrake.math.RotationMatrix]: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_𝓣Expression𝓤, precision: float) -> pydrake.symbolic.Formula: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def ShiftToCenterOfMass(self, mass: pydrake.symbolic.Expression, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_𝓣Expression𝓤: ...
    def Trace(self) -> pydrake.symbolic.Expression: ...
    @classmethod
    def TriaxiallySymmetric(cls, I_triaxial: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __copy__(self) -> RotationalInertia_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_𝓣Expression𝓤: ...
    def __getitem__(self, arg0: tuple) -> pydrake.symbolic.Expression: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __imul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    def __isub__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __itruediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_𝓣Expression𝓤) -> RotationalInertia_𝓣Expression𝓤: ...
    def __truediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody18LinearSpringDamperIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def bodyB(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody18LinearSpringDamperINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_𝓣Expression𝓤: ...
    def bodyB(self) -> Body_𝓣Expression𝓤: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody23QuaternionFloatingJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣AutoDiffXd𝓤, frame_on_child: Frame_𝓣AutoDiffXd𝓤, angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, R_FM: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def get_position(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_position(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣AutoDiffXd𝓤: ...
    def translational_damping(self) -> float: ...

class _TemporaryName_N5drake9multibody23QuaternionFloatingJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_𝓣Expression𝓤, frame_on_child: Frame_𝓣Expression𝓤, angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, R_FM: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def get_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def get_position(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_position(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_𝓣Expression𝓤: ...
    def translational_damping(self) -> float: ...

class _TemporaryName_N5drake9multibody25LinearBushingRollPitchYawIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_𝓣AutoDiffXd𝓤, frameC: Frame_𝓣AutoDiffXd𝓤, torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def frameC(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def link0(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def link1(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake9multibody25LinearBushingRollPitchYawINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_𝓣Expression𝓤, frameC: Frame_𝓣Expression𝓤, torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_𝓣Expression𝓤: ...
    def frameC(self) -> Frame_𝓣Expression𝓤: ...
    def link0(self) -> Body_𝓣Expression𝓤: ...
    def link1(self) -> Body_𝓣Expression𝓤: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake9multibody26UniformGravityFieldElementIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def is_enabled(self, model_instance: ModelInstanceIndex) -> bool: ...
    def set_enabled(self, model_instance: ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody26UniformGravityFieldElementINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def is_enabled(self, model_instance: ModelInstanceIndex) -> bool: ...
    def set_enabled(self, model_instance: ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody4BodyIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def body_frame(self) -> BodyFrame_𝓣AutoDiffXd𝓤: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    @overload
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> bool: ...
    @overload
    def is_locked(self) -> Any: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class _TemporaryName_N5drake9multibody4BodyINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def body_frame(self) -> BodyFrame_𝓣Expression𝓤: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    @overload
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> bool: ...
    @overload
    def is_locked(self) -> Any: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class _TemporaryName_N5drake9multibody5FrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, X_FQ: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, R_FQ: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, other_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, measured_in_frame: Frame_𝓣AutoDiffXd𝓤, expressed_in_frame: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_M: Frame_𝓣AutoDiffXd𝓤, frame_E: Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class _TemporaryName_N5drake9multibody5FrameINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, X_FQ: pydrake.math.RigidTransform_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, R_FQ: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, other_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, measured_in_frame: Frame_𝓣Expression𝓤, expressed_in_frame: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_M: Frame_𝓣Expression𝓤, frame_E: Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_𝓣Expression𝓤: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def scoped_name(self) -> ScopedName: ...

class _TemporaryName_N5drake9multibody5JointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def frame_on_parent(self) -> Frame_𝓣AutoDiffXd𝓤: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_𝓣AutoDiffXd𝓤: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class _TemporaryName_N5drake9multibody5JointINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_𝓣Expression𝓤: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_𝓣Expression𝓤: ...
    def frame_on_parent(self) -> Frame_𝓣Expression𝓤: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_𝓣Expression𝓤: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class _TemporaryName_N5drake9multibody9BodyFrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Frame_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake9multibody9BodyFrameINS_8symbolic10ExpressionEEE(Frame_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake9multibody9DoorHingeIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣AutoDiffXd𝓤, config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeSpringTorque(self, angle: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeTorque(self, angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody9DoorHingeINS_8symbolic10ExpressionEEE(ForceElement_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_𝓣Expression𝓤, config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeSpringTorque(self, angle: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeTorque(self, angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody9RigidBodyIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Body_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, mass: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia: ...
    def default_spatial_inertia(self) -> SpatialInertia: ...
    def default_unit_inertia(self) -> UnitInertia: ...

class _TemporaryName_N5drake9multibody9RigidBodyINS_8symbolic10ExpressionEEE(Body_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, mass: pydrake.symbolic.Expression) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia: ...
    def default_spatial_inertia(self) -> SpatialInertia: ...
    def default_unit_inertia(self) -> UnitInertia: ...

class _TemporaryName_N5drake9multibody9WeldJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_𝓣AutoDiffXd𝓤, frame_on_child_M: Frame_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform: ...

class _TemporaryName_N5drake9multibody9WeldJointINS_8symbolic10ExpressionEEE(Joint_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_𝓣Expression𝓤, frame_on_child_M: Frame_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform: ...

def CalcSpatialInertia(*args, **kwargs) -> Any: ...
def default_model_instance() -> ModelInstanceIndex: ...
def world_frame_index() -> FrameIndex: ...
def world_index() -> BodyIndex: ...
def world_model_instance() -> ModelInstanceIndex: ...
